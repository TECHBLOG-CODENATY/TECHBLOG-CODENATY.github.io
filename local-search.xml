<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>[블록체인] 블록</title>
    <link href="/2021/03/23/post09/"/>
    <url>/2021/03/23/post09/</url>
    
    <content type="html"><![CDATA[<h2 id="블록체인-블록"><a href="#블록체인-블록" class="headerlink" title="[블록체인] 블록"></a>[블록체인] 블록</h2><p><img src="/img/contents/illon.jpg"></p></br><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>앞선 포스팅에서는 트랜잭션에 대해서 언급한 바 있다. 트랜잭션의 경우 아직 지불되지 않은 목록인 UTXO라는 트랜잭션 집합을 가지고 있으며 실제로 유효한 거래일 경우 이를 블록체인 네트워크 상에 올릴 수 있도록 수행한다. 하지만 이러한 트랜잭션의 경우는 이중 지불 문제가 발생할 수도 있다. 트랜잭션의 순서를 정하여 비트코인을 사용하려는 트랜잭션 중 첫 번째 것만 유효하고 나머지를 무효로 간주한다면 이를 해결할 수 있다. 이를 블록이라고 한다. 블록은 실시간$^{realtime}$으로 순서가 정해질 경우 좋을 수 있지만 이는 효율적이지 않기 때문에 트랜잭션을 10분마다 정산하도록 한다. 해당 포스팅에서는 블록의 구성내용을 확인해보려고 한다.</p></br><h2 id="코인베이스-트랜잭션"><a href="#코인베이스-트랜잭션" class="headerlink" title="코인베이스 트랜잭션"></a>코인베이스 트랜잭션</h2><p><img src="/img/contents/coinbase-transaction.png"></p><p>코인 베이스 트랜잭션이란 블록마다 첫 번째 트랜잭션이며 비트코인을 발행하는 유일한 트랜잭션이다. 코인 베이스 트랜잭션은 몇가지 특징을 갖는다.</p><blockquote><ol><li>코인베이스 트랜잭션은 정확히 하나의 입력을 갖는다.</li><li>하나의 입력은 이전 트랜잭션 해시값으로 32바이트의 0(00..00)을 갖는다.</li><li>하나의 입력은 이전 트랜잭션의 출력 번호로 ffffffff를 갖는다.</li></ol></blockquote></br><h2 id="해제-스크립트"><a href="#해제-스크립트" class="headerlink" title="해제 스크립트"></a>해제 스크립트</h2><p>코인베이스 트랜잭션의 경우 이전 트랜잭션의 출력이 없기 때문에 입력의 해제 스크립트는 큰 의미가 없다. 코인베이스 트랜잭션의 경우 해제 스크립트는 트랜잭션을 만드는 채굴자가 결정한다. 해제 스크립트의 경우 임이의 데이터를 가지고 있는 경우가 있다. 다음은 최초 비트코인 블록체인 블록의 코인베이스 트랜잭션에 있는 해제 스크립트를 의미한다.</p><div class="code-wrapper"><pre><code class="hljs">&gt;&gt;&gt; from io import BytesIO&gt;&gt;&gt; from script import Script&gt;&gt;&gt; stream = BytesIO(bytes.fromhex(&#39;4d04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73&#39;))&gt;&gt;&gt; s = Script.parse(stream)&gt;&gt;&gt; print(s.cmds[2])b &#39;The Times 03/Jan/2009 Chancellor on brink of second bailout for banks&#39;</code></pre></div></br><h2 id="블록-헤더"><a href="#블록-헤더" class="headerlink" title="블록 헤더"></a>블록 헤더</h2><p><img src="/img/contents/block-header.png"></p><p>블록이란 트랜잭션의 묶음을 의미하며 블록 헤더란 블록에 포함된 트랜잭션에 대한 메타 데이터를 의미한다. 대략 550,000개의 블록이 있을 경우 블록 헤더의 크기가 약 45MB였다. 트랜잭션 ID와 동일하게 블록의 고유성을 표현하기 위한 블록 ID가 존재한다. 블록 ID는 다음 블록 헤더의 이전 블록 해시값(prev_block) 필드로 들어간다.</p><blockquote><p>블록 버전(Version)<br>이전 블록 해시값(Previous block)<br>머클루트(Merkle root)<br>타임스탬프(Timestamp)<br>비트값(Bits)<br>논스값(Nonce)</p></blockquote><p>블록 헤더의 구성요소는 다음과 같으 형태로 이루어져 있다. 블록 버전의 경우는 블록에서 지원하는 소프트웨어 기능의 집합을 의미하며 이전 블록 해시값의 경우 이전 블록의 해시값을 의미한다. 머클루트란 블록 내 순서에 따라 나열된 모든 트랜잭션을 32바이트 해시값으로 변환한 값을 의미한다. 타임스탬프란 유닉스 형식으로 표현된 4바이트를 의미한다. 비트값은 작업증명에 관련된 필드이다. 논스 값은 작업증명을 위해 채굴자가 변경하는 값을 의미한다.</p></br><h2 id="작업-증명"><a href="#작업-증명" class="headerlink" title="작업 증명"></a>작업 증명</h2><p>비트코인에서 흔히 이야기하는 채굴이라는 말을 들어보았을 것이다. 채굴이란 작업 증명을 의미하며 작업증명으로 탈중앙화 방식의 비트코인 채굴이 가능해지며 전체 네트워크 수준에서의 비트코인의 보안이 유지된다. 작업증명이란 특정한 조건을 만족하는 매우 희소한 숫자를 찾는 것을 의미한다.</p><div class="code-wrapper"><pre><code class="hljs">020000208ec39428b17323fa0ddec8e887b4a7c53b8c0a0a220cfd0000000000000000005b0750fce0a889502d40508d39576821155e9c9e3f5c3157f961db38fd8b25be1e77a759e93c0118a4ffd71d</code></pre></div><p>상단의 기재된 블록헤더의 해시값을 통해 작업 증명을 수행해보도록 하면 다음과 같은 프로세스로 이루어진다.</p><div class="code-wrapper"><pre><code class="hljs">&gt;&gt;&gt; from helper import hash256&gt;&gt;&gt; block_id = hash256(bytes.fromhex(&#39;020000208ec39428b17323fa0ddec8e887b4a7c53\b8c0a0a220cfd0000000000000000005b0750fce0a889502d40508d39576821155e9c9e3f5c31\57f961db38fd8b25be1e77a759e93c0118a4ffd71d&#39;))[::-1]&gt;&gt;&gt; print(&#39;&#123;&#125;&#39;.format(block_id.hex()).zfill(64))0000000000000000007e9e4c586439b0cdbe13b1370bdd9435d76a644d047523</code></pre></div><p>일반적으로 무작위의 256비트 숫자의 해시결과가 작은값이 되기 위한 확률은 무수히 낮다. 256비트 숫자에서 첫 번째 비트가 0일 확률을 0.5이며 처음 두비트가 00일 확률은 0.25이다. 결과적으로 $0.5^n$의 확률이므로 작은 숫자일 수록 확률이 매우 낮아진다.</p><p>이러한 작업증명을 만족하는 조건을 이루기 위한 숫자는 논스값을 통해 얻을 수 있다. 채굴자의 경우 원하는 대로 논스값을 변경하여 블록 헤더의 해시값을 변경할 수 있다. 하지만 4바이트의 논스값의 경우 0.0003초만에 확인할 수 있기에 추가적으로 채굴자는 코인베이스 트랜잭션을 변경할 수 있어 머클루트가 변경되어 난이도가 더 어려워질 수 있다.</p></br><h3 id="목표값"><a href="#목표값" class="headerlink" title="목표값"></a>목표값</h3><p>작업증명의 요구사항은 비트코인의 모든 블록 헤더의 해시값이 특정 값보다 작아야 한다. 목표값은 블록 헤더의 비트값으로 계산된 256비트 숫자이다. 목표값은 4바이트로 이루어진 값이며 지수$^{exponent}$와 계수$^{coefficient}$로 나뉜다. 마지막 바이트의 경우가 지수이고 처음 세 바이트의 리틀엔디언 형식이 계수이다.</p></br><div class="code-wrapper"><pre><code class="hljs">target = coefficient x 256^(exponent-3)</code></pre></div></br><div class="code-wrapper"><pre><code class="hljs">&gt;&gt;&gt; from helper import little_endian_to_int&gt;&gt;&gt; bits = bytes.fromhex(&#39;e93c0118&#39;)&gt;&gt;&gt; exponents = bits[-1]&gt;&gt;&gt; coefficient = little_endian_to_int(bits[:-1])&gt;&gt;&gt; target = coefficient * 256 ** (exponent - 3)&gt;&gt;&gt; print(&#39;&#123;:x&#125;&#39;.format(target).zfill(64))0000000000000000013ce9000000000000000000000000000000000000000000</code></pre></div></br><h3 id="난이도-조정"><a href="#난이도-조정" class="headerlink" title="난이도 조정"></a>난이도 조정</h3><p>비트코인에서 2016블록의 각 그룹을 난이도 조정 기간 $^{difficulty \space adjustment \space period}$이라고 한다. 난이도 조정 기간이 끝나면 목표값은 다음 식에 따라 조정된다.</p></br><div class="code-wrapper"><pre><code class="hljs">time_differential = (난이도 조정 기간의 마지막 블록 타임스탬프) - (난이도 조정 기간의 첫 번째 블록 타임 스탬프)</code></pre></div></br><div class="code-wrapper"><pre><code class="hljs">new_target = previous_target * time_differential / (2주간의 초 단위 시간)</code></pre></div></br><div class="code-wrapper"><pre><code class="hljs">&gt;&gt;&gt; from block import Block&gt;&gt;&gt; from helper import TWO_WEEKS&gt;&gt;&gt; from helper import target_to_bits&gt;&gt;&gt; block1_hex = &#39;000000203471101bbda3fe307664b3283a9ef0e97d9a38a7eacd88000000\00000000000010c8aba8479bbaa5e0848152fd3c2289ca50e1c3e58c9a4faaafbdf5803c5448dd\b845597e8b0118e43a81d3&#39;&gt;&gt;&gt; block2_hex = &#39;02000020f1472d9db4b563c35f97c428ac903f23b7fc055d1cfc26000000\000000000000b3f449fcbe1bc4cfbcb8283a0d2c037f961a3fdf2b8bedc144973735eea707e126\4258597e8b0118e5f00474&#39;&gt;&gt;&gt; last_block = Block.parse(BytesIO(bytes.fromhex(block1_hex)))&gt;&gt;&gt; first_block = Block.parse(BytesIO(bytes.fromhex(block2_hex)))&gt;&gt;&gt; time_differential = last_block.timestamp - first_block.timestamp&gt;&gt;&gt; if time_differential &gt; TWO_WEEKS * 4:...     time_differential = TWO_WEEKS * 4&gt;&gt;&gt; if time_differential &lt; TWO_WEEKS // 4:...     time_differential = TWO_WEEKS // 4&gt;&gt;&gt; new_target = last_block.target() * time_differential // TWO_WEEKS&gt;&gt;&gt; new_bits = target_to_bits(new_target)&gt;&gt;&gt; print(new_bits.hex())80df6217</code></pre></div></br><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><div class="code-wrapper"><pre><code class="hljs">Programming Bitcoin,밑바닥부터 시작하는 비트코인 (송재준 지음)https://github.com/jimmysong/programmingbitcoin/blob/master/ch09.asciidoc</code></pre></div></br><h2 id="한줄평"><a href="#한줄평" class="headerlink" title="한줄평"></a>한줄평</h2><div class="code-wrapper"><pre><code class="hljs">마음 급하지 않게 차분하게 꾸준히.</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blockchain</tag>
      
      <tag>block</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[블록체인] p2sh 스크립트</title>
    <link href="/2021/03/23/post08/"/>
    <url>/2021/03/23/post08/</url>
    
    <content type="html"><![CDATA[<h2 id="블록체인-p2sh-스크립트"><a href="#블록체인-p2sh-스크립트" class="headerlink" title="[블록체인] p2sh 스크립트"></a>[블록체인] p2sh 스크립트</h2><p><img src="/img/contents/illon.jpg"></p></br><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>트랜잭션을 생성할 경우 비밀키를 이용해서 생성하는 방법에 대해서 알아보았다. 하지만 비밀키가 하나일 경우 모든 위험성이 하나로 집중되기에 문제가 있다. 그래서 비밀키를 하나만 사용하는 것이 아닌 여러개의 비밀키를 사용하는 다중서명 방식을 이용하게 되었다. 다중서명을 이용하는 방식의 스크립트가 p2sh 스크립트를 의미한다.</p></br><h2 id="다중서명"><a href="#다중서명" class="headerlink" title="다중서명"></a>다중서명</h2><p>다중서명의 가장 원시적인$_{primitive}$ 아이디어 중 하나인 베어 다중서명에 대해서 다루려고 한다. 다중서명은 OP_CHECKMULTISIG 명령어를 사용한다. 해당 명령어는 스택 위의 많은 서명과 공개키를 가져와서 유효한 서명의 수가 기준 이상일 경우의 여부를 파악하여 1과 0을 반환한다.</p></br><p><img src="/img/contents/multi-lock.png" alt="다중서명 잠금 스크립트"></p></br><p><img src="/img/contents/multi-unlock.png" alt="다중서명 해제 스크립트"></p><p>상단의 나온 이미지와 같이 잠금 스크립트와 해제 스크립트가 여러개가 위치한 형태로 구성됨을 볼 수 있다.</p></br><p><img src="/img/contents/multisig.png" alt="다중서명 결합 스크립트"></p><p>다음과 같이 잠금 스크립트와 해제 스크립트가 결합한 스크립트는 다음과 같은 형태로 보여진다. 세부적으로 살펴볼 경우 다음과 같은 결합 스크립트에 다수의 공개키와 다수의 서명이 위치한 것을 확인할 수 있다.</p></br><p><img src="/img/contents/prbc_0807.png" alt="다중서명 결합 스크립트"></p><p>스크립트가 실행된 이후 n개의 공개키와 m개의 서명이 담긴 것을 확인할 수 있다. 스택에 최하단에 0이 있는 것을 확인할 수 있는데 이는 OP_CHECKMULTISIG의 실행 특성으로 인한다. OP_CHECKMULTISIG 명령어의 경우 $ m + n + 3 $개의 원소를 스택에서 가져와. $n$개의 공개키 중에서 서로 다른 $m$개의 공개키로 $m$개의 서명이 검증가능한 지 확인한다. 서명이 유효할 경우 스택에 1이 남고 아닐 경우는 0이 남는다.</p></br><h2 id="다중서명의-문제점"><a href="#다중서명의-문제점" class="headerlink" title="다중서명의 문제점"></a>다중서명의 문제점</h2><p>다중서명의 경우 상단에 언급한 바와 같이 n개의 서명을 통해서 스크립트의 유효성을 검증하므로 보안 위험성을 어느정도 완화할 수 있다. 하지만 공개키 및 서명이 모두 포함되어야 하는 스크립트의 특성에 따라 크기가 너무 커지는 것을 의미한다. 이는 가독성, 네트워크에서의 비용 등 모든 오버헤드가 증가함을 의미한다.</p></br><h2 id="p2sh-스크립트"><a href="#p2sh-스크립트" class="headerlink" title="p2sh 스크립트"></a>p2sh 스크립트</h2><p><img src="/img/contents/p2sh-pattern.png" alt="다중서명 잠금 스크립트"></p><p>p2sh(Pay-to-Script-Hash) 스크립트의 경우 길이가 긴 스크립트를 대신하여 스크립트의 짧은 해시값을 제시하고 원래의 긴 스크립트를 해제 할 경우 드러난다. p2sh 스크립트의 경우 상단의 그림과 같은 특별한 패턴을 가지고 있다. 해당 패턴의 명령어들이 실행된 후 유효성이 검증되어 스택에 1을 남기면 리딤 스크립트를 파싱한다.</p></br><p><img src="/img/contents/redeem-script.png" alt="p2sh 리딤 스크립트"></p><p>리딤 스크립트의 경우 다음과 같이 구성되어 있다. 74d691da1574e6b3c192ecfb52cc8984ee7b6c56은 해당 리딤 스크립트의 해쉬값을 의미한다.</p></br><p><img src="/img/contents/p2sh-lock-script.png" alt="p2sh 잠금 스크립트"></p><p>p2sh 잠금 스크립트를 확인할 경우 스크립트가 필요한 곳에 리딤 스크립트의 해시값이 위치한 것을 확인할 수 있다.</p></br><p><img src="/img/contents/p2sh-unlock-script.png" alt="p2sh 해제 스크립트"></p><p>p2sh 해제 스크립트는 다음과 같은 예시를 들 수 있다. 서명과 리딤 스크립트가 위치한 것을 알 수 있다.</p></br><h2 id="p2sh-스크립트의-실행"><a href="#p2sh-스크립트의-실행" class="headerlink" title="p2sh 스크립트의 실행"></a>p2sh 스크립트의 실행</h2><p><img src="/img/contents/p2sh-script.png" alt="p2sh 결합스크립트"></p><p>p2sh의 결합스크립트의 경우 다음과 같은 형태로 결합될 수 있다. 이를 순차적으로 실행시키다보면 Script에는 앞서 언급했던 형태의 패턴들이 형성되게 된다. 이를 절차적인 순서를 통해 확인해볼 경우 더욱 직관적이다.</p></br><p><img src="/img/contents/p2sh-pattern-script.png" alt="p2sh 스크립트 진행 단계"></p><p>RedeemScript가 스택으로 이동하기 전 패턴을 보이고 있다. 결과적으로 다음과 같은 패턴을 수행하며 리딤 스크립트의 해시값과 잠금스크립트의 해시를 비교하여 해당 해시가 일치할 경우 스택에 최상단에는 1이 남게 된다.</p></br><p><img src="/img/contents/parse-redeem.png" alt="리딤스크립트 파싱"></p><p>서명이 유효하기에 결과적으로 리딤스크립트를 파싱하게 되며 명령어 셋이 수행되게 된다. 결과적으로 다음의 모양은 OP_CHECKMULTISIG 명령어를 수행하는 형태의 명령어 셋(instruction set)이 된다.</p></br><h2 id="p2sh-서명-검증"><a href="#p2sh-서명-검증" class="headerlink" title="p2sh 서명 검증"></a>p2sh 서명 검증</h2><p>p2sh의 서명 검증의 경우 <u>[블록체인] 트랜잭션 검증과 생성</u>에서 다루었던 검증과 매우 유사하기에 이를 생략하도록 한다. 더 자세히 알고 싶은 사람을 위해서 출처를 남기도록 하겠다.</p></br><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><div class="code-wrapper"><pre><code class="hljs">Programming Bitcoin,밑바닥부터 시작하는 비트코인 (송재준 지음)https://github.com/jimmysong/programmingbitcoin/blob/master/ch08.asciidoc</code></pre></div></br><h2 id="한줄평"><a href="#한줄평" class="headerlink" title="한줄평"></a>한줄평</h2><div class="code-wrapper"><pre><code class="hljs">코딩하고 싶어요.</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blockchain</tag>
      
      <tag>p2sh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[블록체인] 트랜잭션 검증과 생성</title>
    <link href="/2021/03/20/post07/"/>
    <url>/2021/03/20/post07/</url>
    
    <content type="html"><![CDATA[<h2 id="블록체인-트랜잭션-검증과-생성"><a href="#블록체인-트랜잭션-검증과-생성" class="headerlink" title="[블록체인] 트랜잭션 검증과 생성"></a>[블록체인] 트랜잭션 검증과 생성</h2><p><img src="/img/contents/illon.jpg"></p></br><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>트랜잭션은 디지털 재화를 주고 받는 일종의 매커니즘을 정보 시스템 상에서 구현된 것을 의미한다고 하였다. 또한 디지털 재화의 경우 소유권이 있으며 소유권자만이 본인이 가진 비트코인을 지급할 수 있어야 한다. 이러한 매커니즘을 구현하기 위해서는 서명과 검증에 대해서 논의를 했으며 트랜잭션 상에서는 어떠한 방식으로 검증과 생성이 이루어지는 것을 구체적으로 다루려고 한다.</p></br><h2 id="트랜잭션-검증"><a href="#트랜잭션-검증" class="headerlink" title="트랜잭션 검증"></a>트랜잭션 검증</h2><p>트랜잭션은 소유권자의 재화가 수신자에게 전달되는 것을 표현한다고 하였다. 재화가 오가는 만큼 트랜잭션의 경우 해당 거래가 유효한지 명확한 검증이 이루어져야 한다. 이를 트랜잭션 검증이라고 하며 검증을 위해서 확인해야만 하는 주요 항목은 다음과 같다.</p></br><blockquote><ol><li>트랜잭션의 입력이 가리키는 비트코인이 존재하고 사용 가능한가?</li><li>입력 비트코인의 합은 출력 비트코인의 합보다 크거나 같은가?</li><li>입력의 해제 스크립트는 참조하는 트랜잭션 출력의 잠금 스크립트를 해제하는가?</li></ol></blockquote></br><p>이를 현실세계와 대비해서 쉽게 해석 하면 금고 안의 돈이 있을 경우를 확인하며, 내가 꺼내려고 하는 돈이 금고안의 돈보다 작은지 확인하는 것이다. 마지막으로 금고에 맞는 열쇠가 있어야 금고안의 돈을 꺼낼 수 있을 것이다.</p></br><h2 id="입력-비트코인-존재-확인"><a href="#입력-비트코인-존재-확인" class="headerlink" title="입력 비트코인 존재 확인"></a>입력 비트코인 존재 확인</h2><p>다음의 검증항목을 이해하기 위해서는 UTXO 트랜잭션 집합의 특성을 이해할 필요가 있다. UTXO 트랜잭션은 아직 수신자에게 지불되지 않은 형태를 기술한 것이며 미래 시점에 지급이 이루어지게 된다. 만약 이러한 형태를 취약점으로 생각해서 내 잔고에 금액이 이 만큼 있으니 지불할 것이다와 같은 어음과 같은 형태는 무수히 많이 발행할 수 있으며 이는 이중지불 문제에 부딪히게 된다.</p><p>그러한 이유로 이러한 이중지불 문제에 대해서 해결이 이루어져야 하며 비트코인의 경우는 전체 트랜잭션 집합으로부터 계산된 UTXO 집합을 찾아볼 수 있어야만 한다. 풀 노드의 경우는 이중 지불 여부를 상대적으로 쉽게 확인할 수 있으며 라이트 노드의 경우는 더 많은 정보를 풀 노드에 의존해야 한다.</p></br><h2 id="입력과-출력-비트코인-합계-확인"><a href="#입력과-출력-비트코인-합계-확인" class="headerlink" title="입력과 출력 비트코인 합계 확인"></a>입력과 출력 비트코인 합계 확인</h2><p>트랜잭션에서 수수료의 경우는 입력 비트코인에서 출력 비트코인의 감한 값을 의미한다. 채굴자에게는 이에 해당하는 금액이 보상으로 지급되며 이것이 수수료를 의미한다. 만약 출력 비트코인의 양이 더 많다면 이는 결과적으로 마이너스 형태의 수수료가 되며 이는 네트워크의 총 비트코인 통화량이 늘어나는 것을 의미한다. 이런 일은 발생할 경우 블록체인 네트워크의 신뢰성을 무너뜨릴 만큼 심각한 문제라서 이러한 문제가 발생하면 안된다.</p></br><h2 id="서명-확인"><a href="#서명-확인" class="headerlink" title="서명 확인"></a>서명 확인</h2><p>디지털 재화의 경우 소유권이 있으며 소유권자만이 본인이 가진 비트코인을 지급할 수 있어야 한다고 언급하였다. 비트코인에서는 ECDSA 서명 알고리즘을 이용해서 이를 해결하였으며 해당 알고리즘에서 서명을 검증하기 위해서는 공개키 $P$, 서명해시 $z$, 서명 $(r,s)$를 필요로 한다.</p><p><img src="/img/contents/transaction-input.png"></p><p>상단의 그림의 하늘색 부분이 해제 스크립트이며 서명의 경우 해제 스크립트 안에 있다. 공개키와 서명은 쉽게 알아낼 수 있지만 서명해시($z$)를 구하는 것은 상대적으로 복잡한 과정을 거친다. 다음과 같이 트랜잭션을 단계별로 변형하여 서명해시를 구할 수 있다. </p></br><blockquote><ol><li>모든 해제 스크립트를 비운다.</li><li>삭제된 해제 스크립트 자리에 사용할 UTXO의 잠금 스크립트를 삽입한다.</li><li>해시 유형을 덧붙인다.</li></ol></blockquote></br><h3 id="STEP1-모든-해제-스크립트를-비운다"><a href="#STEP1-모든-해제-스크립트를-비운다" class="headerlink" title="STEP1. 모든 해제 스크립트를 비운다."></a>STEP1. 모든 해제 스크립트를 비운다.</h3><p><img src="/img/contents/step1.png"></p><p>해제 스크립트에 해당하는 부분이 0으로 설정된 것을 확인할 수 있다.</p></br><h3 id="STEP2-삭제된-해제-스크립트-자리에-사용할-UTXO의-잠금-스크립트를-삽입한다"><a href="#STEP2-삭제된-해제-스크립트-자리에-사용할-UTXO의-잠금-스크립트를-삽입한다" class="headerlink" title="STEP2. 삭제된 해제 스크립트 자리에 사용할 UTXO의 잠금 스크립트를 삽입한다."></a>STEP2. 삭제된 해제 스크립트 자리에 사용할 UTXO의 잠금 스크립트를 삽입한다.</h3><p><img src="/img/contents/combine-script.png"></p><p><img src="/img/contents/step2.png"></p><p>입력이 가리키는 이전 트랜잭션에서 출력의 잠금 스크립트(ScriptPubKey)를 찾아 해제 스크립트 자리에 삽입합니다.</p></br><h3 id="STEP3-해시-유형을-덧붙인다"><a href="#STEP3-해시-유형을-덧붙인다" class="headerlink" title="STEP3. 해시 유형을 덧붙인다."></a>STEP3. 해시 유형을 덧붙인다.</h3><p><img src="/img/contents/step3.png"></p><p>서명이 입력을 인증하는지 출력을 인증하는지 아니면 둘 다 인증하는지에 대한 해시 유형을 덧붙인다.</p></br><h3 id="STEP4-수정된-트랜잭션을-hash256을-통해-산출한-후-빅엔디언-형식으로-추출한다"><a href="#STEP4-수정된-트랜잭션을-hash256을-통해-산출한-후-빅엔디언-형식으로-추출한다" class="headerlink" title="STEP4. 수정된 트랜잭션을 hash256을 통해 산출한 후 빅엔디언 형식으로 추출한다."></a>STEP4. 수정된 트랜잭션을 hash256을 통해 산출한 후 빅엔디언 형식으로 추출한다.</h3><div class="code-wrapper"><pre><code class="hljs">&gt;&gt;&gt; from helper import hash256&gt;&gt;&gt; modified_tx = bytes.from(&#39;0100000001c84dcc25da0941ef00793d6bbaf99285453913e7ca307fe82dbaffa83c681494010000001976a914a802fc56c704ce87c42d7c92eb75e78996bdc41ae88acffffffff02dd4100000000000017a91431c1b1aca4dcc16783d35c23fde8b2a4c871de7587ac620000000000001976a9147aa8696be3f3dfa6f4363786c681d2070a10a7a988ac0000000001000000&#39;)&gt;&gt;&gt; h256 = hash256(modified_tx)&gt;&gt;&gt; z = int.from_bytes(h256, &#39;big&#39;)&gt;&gt;&gt; print(hex(z))0x27e0c5994dec7824e56dec6b2fcb342eb7cdb0d0958c2fce9882f715e85d81a6</code></pre></div></br><h2 id="트랜잭션-생성"><a href="#트랜잭션-생성" class="headerlink" title="트랜잭션 생성"></a>트랜잭션 생성</h2>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blockchain</tag>
      
      <tag>transaction</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[블록체인] 스크립트</title>
    <link href="/2021/03/18/post06/"/>
    <url>/2021/03/18/post06/</url>
    
    <content type="html"><![CDATA[<h2 id="블록체인-스크립트"><a href="#블록체인-스크립트" class="headerlink" title="[블록체인] 스크립트"></a>[블록체인] 스크립트</h2><p><img src="/img/contents/illon.jpg"></p></br><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>비트코인의 경우 재화를 가지고 있는 소유권자와 재화를 전달받고자 하는 수신자에게 디지털 재화들이 전달되는 것이 구현되어야만 이는 재화로써의 유의미한 가치를 지니게 된다. 비트코인의 경우에도 이러한 형태들이 구현이 되어 있으며 이를 트랜잭션이라고 한다. 하지만 트랜잭션이 일어나기 위해서는 소유권자만이 본인이 가진 비트코인을 지급하거나 전달할 수 있어야 한다. 결과적으로 잠금&#x2F;해제 매커니즘이 일어나야하며 이를 스마트 계약$_{smart contract}$라고 한다.</p></br><h2 id="스크립트"><a href="#스크립트" class="headerlink" title="스크립트"></a>스크립트</h2><p>스크립트란 비트코인에서 스마트 계약이 일어나기 위한 조건을 기술하는 프로그래밍 언어이다. 스크립트는 스택기반의 자료구조에서 일종의 로직을 수행하는 형태의 프로그램 언어이다. 스크립트는 일반적인 언어와 다르게 반복 작업을 위한 루프 기능이 없으며 튜링 불완전한 언어이다. 이는 잘못된 조건으로 인해서 루프를 빠져나오지 못할 경우 비트코인의 네트워크가 멈출 가능성이 있기 때문이다.</p><p>트랜잭션이 이뤄지기 위해서는 잠금 스크립트와 해제 스크립트가 필요하다. 즉, 해제 스크립트로 잠금 스크립트에 해당하는 금고의 소유권을 증명하고 돈을 사용할 수 있기 때문이다.</p></br><h2 id="스크립트-구조"><a href="#스크립트-구조" class="headerlink" title="스크립트 구조"></a>스크립트 구조</h2><p><img src="/img/contents/script.JPG"></p><p>스크립트란 프로그래밍 언어이다. 스크립트는 스택을 기반으로 하나 하나를 처리하며 이와 유사한 형태는 나만의 해석으로 이야기하면 ROP$_{return oriented programming}$과 비슷한 형태의 느낌이였다. 스택에 쌓일 수 있는 두 가지 형태의 정보는 원소와 연산자이다. 원소는 프로그래밍 언어에서 함수의 파라미터라고 해석하는 것이 이해하기 쉬우며 연산자는 원소를 기반으로 로직을 수행하는 어셈블리 명령어라고 생각하면 이해하기 편할 것이다.</p><p>정리를 위해서 상단의 그림을 예시로 설명하도록 하겠다. 스크립트 해석 엔진은 스크립트를 스택처럼 생각하며 최상단에서 원소일 경우 추출하여, 스택에 담는다. 결과적으로 5, 9의 경우 스택에 역순으로 담기며 해당 시점에서 스크립트에서 명령어 OP_ADD를 만날 경우 스택 최상단에 담긴 원소의 값에 대해서 가산연산을 수행한다. 결과적으로 스택에 담긴 값은 14가 될 수 있다.</p></br><h2 id="스크립트-파싱"><a href="#스크립트-파싱" class="headerlink" title="스크립트 파싱"></a>스크립트 파싱</h2><p><img src="/img/contents/OPCODE_sample.JPG"></p><p>스크립트 기반의 언어를 해석하기 위해서는 일종의 규칙이 필요하다. 이에 대해서 상세히 기재하려고 한다. 스크립트 최상단의 한 바이트의 값이 n이며 해당 값이 0x01 ~ 0x4b(1~75)일 경우는 n바이트 길이만큼 이어서 읽은 후 숫자를 한 원소로 간주한다. 그렇지 않을 경우는 해당 바이트는 명령어를 의미하는 오피 코드이다.</p><p>오피 코드의 경우는 예시로 스택의 최상단의 원소를 복사하는 경우와 같이 각 정의된 숫자별로 수행하는 동작이 다르다. 이에 대한 상세한 오피코드의 경우 <a href="https://en.bitcoin.it/wiki/Script">https://en.bitcoin.it/wiki/Script</a> 다음의 페이지에서 정의되어 있으며 이를 통해서 확인할 수 있다.</p><p>주요한 오피 코드 중 하나인 OP_CHECKSIC는 스택 위의 2개의 원소를 가져와서 첫 번째 원소는 공개키로, 두 번째 원소는 서명으로 간주하여 서명을 공개키로 검증한다. 검증에 대해서 성공할 경우 1, 실패할 경우 0을 스택에 최상단에 올린다. 이는 잠금&#x2F;해제 스크립트를 활용하는 데 주요한 역할을 하니 꼭 기억해두어야 한다.</p></br><h2 id="잠금-x2F-해제-스크립트의-결합"><a href="#잠금-x2F-해제-스크립트의-결합" class="headerlink" title="잠금&#x2F;해제 스크립트의 결합"></a>잠금&#x2F;해제 스크립트의 결합</h2><p><img src="/img/contents/combine-script.png"></p><p>트랜잭션이 실행되기 위해서는 잠금 스크립트(ScriptPubKey)와 해제 스크립트(ScriptSig)가 결합되어 실행되어야 만 한다. 잠금 스크립트와 해제 스크립트는 서로 다른 트랜젝션에 있다. 상단의 그림과 같은 형태로 참조하여 잠금&#x2F;해제 스크립트를 결합한 결합 스크립트를 만들 수 있다.</p></br><h2 id="표준-스크립트"><a href="#표준-스크립트" class="headerlink" title="표준 스크립트"></a>표준 스크립트</h2><p>일반적으로 많이 사용되는 패턴의 로직이 함수화되어 있는 것과 같이 스크립트 또한 패턴화 되어 있는 표준을 정의한 형태의 스크립트가 존재한다. 이를 표준 스크립트라고 하며 다음과 같은 예시를 들 수 있다.</p><blockquote><p>p2pk: Pay-to-pubkey<br>p2pkh: Pay-to-pubkey-hash<br>p2sh: Pay-to-script-hash<br>p2wpkh: Pay-to-witness-pubkey-hash<br>p2wsh: Pay-to-witness-script-hash</p></blockquote><p>자세한 스크립트의 패턴화되어 있는 경우는 보다 구체적으로 설명하도록 하겠다.</p></br><h2 id="p2pk-스크립트"><a href="#p2pk-스크립트" class="headerlink" title="p2pk 스크립트"></a>p2pk 스크립트</h2><p>비트코인 트랜잭션이 수행하기 위해서는 잠금 스크립트(ScriptPubKey)와 해제 스크립트(ScriptSig)가 결합하여 해제가 수행되어야 한다는 사실을 알았다. 비밀키 소유자는 서명을 통해 비트코인을 해제하고 사용할 수 있으며, 트랜잭션의 잠금 스크립트는 비밀키 소유자만 할당된 비트코인에 접근할 수 있도록 잠근다.</p><p><img src="/img/contents/ScriptPubKey.jpg" alt="p2pk 잠금 스크립트(ScriptPubKey)"></p><p>다음의 경우는 p2pk 형식의 잠금 스크립트를 의미한다. 마지막 부분에 OP_CHECKSIG를 통해서 서명의 유효성을 검증한다.</p></br><p><img src="/img/contents/ScriptSig.jpg" alt="p2pk 해제 스크립트(ScriptSig)"></p><p>다음의 경우는 p2pk 형식의 해제 스크립트를 의미한다.</p></br></br><p><img src="/img/contents/combine-script-stack.jpg" alt="잠금-해제 결합 스크립트1"></p><p>잠금 스크립트(ScriptPubkey)와 해제 스크립트(ScriptSig)가 결합된 형태는 상단의 그림과 같다.</p></br></br><p><img src="/img/contents/execute-script.png" alt="잠금-해제 결합 스크립트3"></p><p>스크립트 내부에서 하나의 원소를 추출하며 다음과 같은 형태의 스택 구성이 된다. 결과적으로 OP_CHECKSIG가 수행되는 경우 공개키와 서명을 통해 검증이 이루어진 경우 결과가 1이 되어 스택이 남게되며 실패할 경우 0이 스택에 남게된다.</p><p>P2PK의 스크립트는 몇 가지 문제점을 가지고 있다. 공개키의 길이가 길어 가독성이 떨어지며 메모리 자원과 인덱싱을 위한 계산 자원을 차지하여 풀 노드에게 부담이 된다. 또한 공개키가 공개된 잠금 스크립트 안에 있다. ECDSA의 암호 체계가 깨진다면 위험할 수 있다. 결과적으로 추가적인 보호장치를 마련하면 보다 좋은 스크립트 형식을 산출할 수 있다.</p></br><h2 id="p2pkh-스크립트"><a href="#p2pkh-스크립트" class="headerlink" title="p2pkh 스크립트"></a>p2pkh 스크립트</h2><p>p2pkh(Pay-to-pubkey-hash) 스크립트는 p2pk의 문제점을 보완한 형태의 스크립트이다.</p><blockquote><ol><li>짧은 주소 사용</li><li>sha256과 ripemd160 해시함수에 의한 추가적인 보호 장치 추가</li></ol></blockquote><p>sha256 해시값과 ripemd160 해시값을 활용하는 형태를 hash160 해시값이다. hash160 해시값은 160비트 20바이트 형태의 값이다. </p><p><img src="/img/contents/p2pkh-lock.png" alt="p2pkh 잠금 스크립트"></p><p>P2PKH 잠금 스크립트의 예시이다.</p></br><p><img src="/img/contents/p2pkh-unlock.jpg" alt="p2pkh 해제 스크립트"></p><p>P2PKH 해제 스크립트의 예시이다.</p></br><p><img src="/img/contents/p2pkh-script.png" alt="p2pkh 결합 스크립트"></p><p>P2PKH 결합 스크립트의 예시이다. 우측의 결합된 스크립트를 통해 스크립트 해석 엔진으로 순차적으로 해석할 경우 다음과 같은 형태로 이루어지게 된다.</p></br><blockquote><ol><li>Signature와 pubkey 순차로 스택에 쌓인다.</li><li>OP_DUP 명령어를 통해서 스택에 pubkey를 복사한다.</li><li>OP_HASH160 pubkey를 hash로 바꾼다.</li><li>Script에 hash를 스택에 쌓는다.</li><li>현재 상황에서는 스택에는 hash1, hash2가 위치하고 있고 OP_EQUALVERIFY를 통해 두 해시값이 동일한 지 검증한다.</li><li>검증이 완료될 경우 OP_CHECKSIG를 통해 pubkey와 signature를 통해 서명이 정상적인지 검증한다.</li></ol></blockquote></br><p>다음의 프로세스를 통해 p2pkh 스크립트의 검증이 이루어진다.</p></br><h2 id="비표준-스크립트"><a href="#비표준-스크립트" class="headerlink" title="비표준 스크립트"></a>비표준 스크립트</h2><p><img src="/img/contents/unstandard-script.jpg" alt="비표준 스크립트"></p><p>스크립트의 경우 꼭 표준 스크립트만 사용해야 하는 경우가 아니다. 튜링 완전하진 않지만 프로그래밍 언어의 특성을 가지고 있기 때문에 자유도가 높다. 그러한 이유로 표준 형태의 스크립트만 사용할 수 있는 것은 아니다.</p><p>상단의 스크립트를 해석해보면 다음과 같은 프로세스로 이루어진다.</p><blockquote><ol><li>OP_4와 OP_5를 통해 스택에 4와 5를 순차적으로 쌓는다.</li><li>4와 5를 통해 OP_ADD 연산자를 통해 더한다. 이를 통해 스택에 9가 남는다.</li><li>OP_9를 통해 스택에 두 개의 9가 남는다.</li><li>OP_EQUAL을 통해 9와 9를 비교하여 1이 산출된다.</li></ol></blockquote></br><p>다음을 통해 스크립트가 어떤 일을 하는 지 파악할 수 있다.</p><blockquote><p>OP_2DUP<br>OP_EQUAL<br>OP_NOT<br>OP_VERIFY<br>OP_SHA1<br>OP_SWAP<br>OP_SHA1<br>OP_EQUAL</p></blockquote><p>다음은 $x \neq y$ 이며 $sha1(x) &#x3D; sha1(y)$ 인 $(x, y)$를 찾는 형태이다. 즉 SHA-1에 대한 해시충돌을 찾는 것이다. 이러한 형태로 비표준 스크립트를 정의할 수 있다.</p></br><h2 id="한줄평"><a href="#한줄평" class="headerlink" title="한줄평"></a>한줄평</h2><div class="code-wrapper"><pre><code class="hljs">ROP 몰랐으면 절었다.</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blockchain</tag>
      
      <tag>script</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[블록체인] 트랜잭션</title>
    <link href="/2021/03/17/post05/"/>
    <url>/2021/03/17/post05/</url>
    
    <content type="html"><![CDATA[<h2 id="블록체인-트랜잭션"><a href="#블록체인-트랜잭션" class="headerlink" title="[블록체인] 트랜잭션"></a>[블록체인] 트랜잭션</h2><p><img src="/img/contents/illon.jpg"></p></br><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>비트코인의 경우 재화를 가지고 있는 소유권자와 재화를 전달받고자 하는 수신자에게 디지털 재화들이 전달되는 것이 구현되어야만 이는 재화로써의 유의미한 가치를 지니게 된다. 비트코인의 경우에도 이러한 형태들이 구현이 되어 있으며 이를 트랜잭션이라고 한다. 즉, 트랜잭션은 한 엔터티에서 다른 엔터티로의 가치 이동을 표현한다. 이러한 트랜잭션 또한 디지털 데이터의 형식이므로 포맷에 맞추어 지정이 되어 있다. 포맷을 분석하며 트랜잭션의 구성요소를 파악하고 의미를 확인해보려고 한다.</p></br><h2 id="트랜잭션-구성요소"><a href="#트랜잭션-구성요소" class="headerlink" title="트랜잭션 구성요소"></a>트랜잭션 구성요소</h2><p><img src="/img/contents/transaction.png"></p></br><blockquote><ol><li>버전(Version)</li><li>입력(Inputs)</li><li>출력(Outputs)</li><li>록타임(Locktime)</li></ol></blockquote></br><p>트랜젝션은 다음 네 가지 요소로 구성된다. 버전의 경우 트랜잭션의 버전을 의미한다. 입력의 경우 사용할 비트코인을 정의하고, 출력의 경우 비트코인이 어디로 가는지 종착지를 정의한다. 록타임은 트랜잭션의 유효시점을 규정한다.</p></br><h2 id="버전"><a href="#버전" class="headerlink" title="버전"></a>버전</h2><p><img src="/img/contents/version.png"></p><p>버전의 경우 비트코인 트랜잭션의 버전 정보를 의미한다. 해당 값은 4바이트로 리틀엔디언의 형태로 표현되어 있다. 결과적으로 상단의 나온 그림에서의 버전은 1이라고 확인할 수 있다.</p></br><h2 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h2><p><img src="/img/contents/transaction-input.png"></p></br><blockquote><ol><li>입력의 수(Input Numbers)</li><li>이전 트랜잭션의 해시값 혹은 ID(Previous Tx ID)</li><li>이전 트랜잭션의 출력 번호(Previous Tx index)</li><li>해제 스크립트(ScriptSig)</li><li>시퀀스(Sequence)</li></ol></blockquote></br><p>입력의 경우 입력의 수, 이전 트랜잭션의 해시값, 출력 번호, 해제 스크립트, 시퀀스로 나뉜다. 입력 수의 경우 해당 트랜잭션의 비트코인의 입력 수를 의미한다. 트랜잭션 별로 한 개의 입력만이 존재하지 않을 수 있기 때문이다. 또한 가변 정수의 형태로 표현이 이뤄진다. 표현 범위에 따라서 입력수 바이트의 크기가 변경될 수 있다.</p><p>다음으로 이전 트랜잭션의 해시값과 출력번호를 설명한다. 상단의 그림에서 표현된 부분의 빨간색을 의미하며 이는 리틀엔디언 형태로 해석할 경우 이전 트랜잭션의 해시값이 된다. 출력 번호 또한 리틀 엔디언으로 해석한다. </p><p>다음으로 해제 스크립트를 표현하며 해제 스크립트의 경우는 길이가 가변적으로 변하는 필드이다. 이를 파싱하기 위해서는 정확한 길이를 알아야 하며 이는 향후 보다 구체적으로 설명한다.</p><p>마지막으로 시퀀스 필드를 의미한다. 초기 목적은 록타임 필드로 활용하여 매우 빈번한 거래를 효율적으로 처리하기 위함이였으나 현재는 RBF와 OP_CHECKSEQUENCEVERIFY로 사용되고 있다.</p></br><h2 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h2><p><img src="/img/contents/transaction-output.png"></p></br><blockquote><ol><li>출력의 수(Output Numbers)</li><li>비트코인 금액</li><li>잠금 스크립트(ScriptPubKey)</li></ol></blockquote></br><p>출력의 경우 출력의 수, 비트코인 금액, 잠금 스크립트로 나뉜다. 출력 수의 경우 해당 트랜잭션의 비트코인의 출력 수를 의미한다. 트랜잭션 별로 여러 명에게 금액을 보내고자 하는 경우가 있기 때문이다. 또한 가변 정수의 형태로 표현이 이뤄진다. 표현 범위에 따라서 출력 수 바이트의 크기가 변경될 수 있다.</p><p>다음으로 비트코인의 금액이다. 보다 구체적으로 설명할 경우, 사토시의 단위로 표현하며, 출력이 내포하는 비트코인의 양을 의미한다. 이를 리틀엔디언으로 표현하며 상단의 나온 이미지의 경우 16,861satoshi로 0.00016861BTC을 의미한다.</p><p>마지막으로 잠금 스크립트를 의미하며 비트코인이 담긴 금고, 즉 누구든지 돈을 넣을 수는 있지만 해제하기 위해서는 금고 열쇠 소유자만이 열수 있는 금고라고 생각하면 된다. 이는 다음 장에서 보다 구체적으로 설명할 예정이다.</p></br><h2 id="록타임"><a href="#록타임" class="headerlink" title="록타임"></a>록타임</h2><p><img src="/img/contents/transaction-locktime.png"></p></br><blockquote><ol><li>록타임(Locktime)</li></ol></blockquote></br><p>록타임은 트랜잭션 전파 후 실행을 지연시키는 방법을 제공한다. 예를 들어 600,000의 록타임 값을 가지는 경우 트랜잭션은 600,001블록까지는 블록체인에 포함될 수 없다. 록타임 값이 500,000,000보다 클 경우는 유닉스 타임으로 해석하며 그 이하일 경우 블록의 높이로 해석한다. 록타임 시점이 도달하기 전까지는 비트코인을 소비할 수 없다.</p></br><h2 id="트랜잭션-수수료"><a href="#트랜잭션-수수료" class="headerlink" title="트랜잭션 수수료"></a>트랜잭션 수수료</h2></br><p>지금까지 다룬 트랜잭션은 블록체인 블록에 포함되지 않은 형태의 트랜잭션을 의미한다. 이러한 트랜잭션이 결정되기 위해서는 채굴자가 트랜잭션을 블록에 포함시켜야 한다. 이러한 작업은 어떠한 보상이 있어야 하며 이러한 보상은 수수료로 결정된다.</p><p>수수료는 비트코인 금액의 입력의 합에서 출력의 합을 뺀 값을 의미한다. 채굴자는 채굴을 통해서 이를 가져간다. 입력은 금액 필드를 가지고 있지 않기 때문에 금액이 입력이 가리키는 이전 트랜잭션의 출력에서 찾아야 한다.</p></br><h2 id="실습-트랜잭션-파싱"><a href="#실습-트랜잭션-파싱" class="headerlink" title="실습 - 트랜잭션 파싱"></a>실습 - 트랜잭션 파싱</h2></br><p>앞서 기재했던 정보들을 토대로 이해를 도모하기 위해서 나만의 파서(parser)를 구현해보앗다.</p><p><img src="/img/contents/transaction-practice.JPG"></p></br><p>기재된 트랜잭션 정보에 대한 파싱을 수행해보려고 한다.</p></br><div class="code-wrapper"><pre><code class="hljs">from selenium import webdriverfrom pyvirtualdisplay import Displayfrom selenium.webdriver.chrome.service import Servicefrom webdriver_manager.chrome import ChromeDriverManagerimport osimport warningswarnings.filterwarnings(&quot;ignore&quot;)# display = Display(visible=1, size=(1920, 1080))# display.start()def set_chrome_driver():        # chrome_options = webdriver.ChromeOptions()    os.environ[&#39;WDM_LOG_LEVEL&#39;] = &#39;0&#39;    options = webdriver.ChromeOptions()    options.add_argument(&quot;--headless&quot;)    options.add_argument(&quot;start-maximized&quot;)    options.add_experimental_option(&#39;excludeSwitches&#39;, [&#39;enable-logging&#39;])        driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=options)    # driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=chrome_options)    return driverprev_transaction_index = 0def parseInputSize(data):    global prev_transaction_index    input_size_index = 5        if(data[4] == 0xff):        # print(&quot;가변길이 8바이트&quot;)        prev_transaction_index = input_size_index + 8        print(&quot;    입력 개수(Input Size): &#123;&#125;&quot;.format(int.from_bytes(data[5:prev_transaction_index], byteorder=&#39;little&#39;)))    elif(data[4] == 0xfe):        # print(&quot;가변길이 4바이트&quot;)            prev_transaction_index = input_size_index + 4        print(&quot;    입력 개수(Input Size): &#123;&#125;&quot;.format(int.from_bytes(data[5:prev_transaction_index], byteorder=&#39;little&#39;)))    elif(data[4] == 0xfd):        # print(&quot;가변길이 2바이트&quot;)        prev_transaction_index = input_size_index + 2        print(&quot;    입력 개수(Input Size): &#123;&#125;&quot;.format(int.from_bytes(data[5:prev_transaction_index], byteorder=&#39;little&#39;)))    else:        # print(&quot;가변길이 1바이트&quot;)        input_size_index = 4        prev_transaction_index = input_size_index + 1        print(&quot;    입력 개수(Input Size): &#123;&#125;&quot;.format(int.from_bytes(data[input_size_index:prev_transaction_index], byteorder=&#39;little&#39;)))    return prev_transaction_indextx_id = &#39;d28fdd43f7446f7bc39e2c2330c73793a72bade05fb34dd4dd6a98bb9703fa1d&#39;tx_id = &#39;d8d983b06fc92317fdb6246fddcdaa589c0f888feb6d953e8376d4968ae44389&#39;tx_id = &#39;4074101a6059c764de75c762ac5f751b0ef6ed1513e9815548a63033de2e8966&#39;tx_id = &#39;995d2f67ca799318415fcf9b9a7c571c4d09915eaaf36ab207cc2d19b839004a&#39;url = &#39;https://btc.bitaps.com/raw/transaction/&#39;url = url + f&#39;&#123;tx_id&#125;&#39;driver = set_chrome_driver()driver.get(url=url)print(&quot;[+] 트랜잭션 정보 추출&quot;)print(&quot;    transaction id: &quot; + tx_id)print(&quot;    transaction url: &quot; + url)transaction_str = driver.find_element_by_id(&#39;raw-tx&#39;).textraw = bytes.fromhex(transaction_str)driver.quit()# print(transaction_str)# print(transaction_str[-4:])#parseInputSize(b&#39;\x00\x00\x00\x00\x64&#39;)#parseInputSize(b&#39;\x00\x00\x00\x00\xfd\xff\x00&#39;)#parseInputSize(b&#39;\x00\x00\x00\x00\xfd\x2b\x02&#39;)#parseInputSize(b&#39;\x00\x00\x00\x00\xfe\x7f\x11\x01\x00&#39;)#parseInputSize(b&#39;\x00\x00\x00\x00\xff\x6d\xc7\xed\x3e\x60\x10\x00\x00&#39;)def to_little(val):little_hex = bytearray.fromhex(val)little_hex.reverse()print(&quot;Byte array format:&quot;, little_hex)str_little = &#39;&#39;.join(format(x, &#39;02x&#39;) for x in little_hex)return str_littleprint(&quot;\n[+] 트랜잭션 구성요소&quot;)print(&quot;    버전(Version): &#123;&#125;&quot;.format(int.from_bytes(raw[0:4], byteorder=&#39;little&#39;)))prev_transaction_index = parseInputSize(raw) * 2prev_transaction = transaction_str[prev_transaction_index:prev_transaction_index+64]prev_transaction = int(prev_transaction, 16).to_bytes(32, byteorder=&quot;little&quot;).hex()print(&quot;    이전 트랜잭션(Prev TX): &#123;&#125;&quot;.format(prev_transaction))prev_transaction_number_index = prev_transaction_index+64prev_transaction_str = transaction_str[prev_transaction_number_index:prev_transaction_number_index+8]prev_transaction_str = int(prev_transaction_str, 16).to_bytes(4, byteorder=&quot;little&quot;).hex()print(&quot;    이전 트랜잭션 출력번호(Prev TX Number): &#123;&#125;&quot;.format(prev_transaction_str))print(&quot;    록타임(Locktime): &#123;&#125;&quot;.format(int.from_bytes(raw[-4:], byteorder=&#39;little&#39;)))</code></pre></div></br><p>조잡하게 구현해보았다.</p></br><blockquote><p>[+] 트랜잭션 정보 추출<br>    transaction id: 995d2f67ca799318415fcf9b9a7c571c4d09915eaaf36ab207cc2d19b839004a<br>    transaction url: <a href="https://btc.bitaps.com/raw/transaction/995d2f67ca799318415fcf9b9a7c571c4d09915eaaf36ab207cc2d19b839004a">https://btc.bitaps.com/raw/transaction/995d2f67ca799318415fcf9b9a7c571c4d09915eaaf36ab207cc2d19b839004a</a></p><p>[+] 트랜잭션 구성요소<br>    버전(Version): 1<br>    입력 개수(Input Size): 1<br>    이전 트랜잭션(Prev TX): 9414683ca8ffba2de87f30cae71339458592f9ba6b3d7900ef4109da25cc4dc8<br>    이전 트랜잭션 출력번호(Prev TX Number): 00000001<br>    록타임(Locktime): 0</p></blockquote></br><p>구현 결과 트랜잭션 정보페이지와 동일한 형태로 값이 산출되었다.</p></br><h2 id="한줄평"><a href="#한줄평" class="headerlink" title="한줄평"></a>한줄평</h2><div class="code-wrapper"><pre><code class="hljs">리틀엔디언, 빅엔디언을 명확히 구분하자.</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blockchain</tag>
      
      <tag>transaction</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[블록체인] 직렬화</title>
    <link href="/2021/03/16/post04/"/>
    <url>/2021/03/16/post04/</url>
    
    <content type="html"><![CDATA[<h2 id="블록체인-직렬화"><a href="#블록체인-직렬화" class="headerlink" title="[블록체인] 직렬화"></a>[블록체인] 직렬화</h2><p><img src="/img/contents/illon.jpg"></p></br><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>블록체인에서 어떤 누군가가 발행한 것이며 이를 어떻게 검증할 것인가에 관한 문제는 신뢰성이 보장되야하는 기록에서는 매우 중요한 요소 중 하나로 볼 수 있다. 이를 위해서 공개키, 비밀키, 서명에 관해서 다루었고 이러한 정보들은 컴퓨터 상에 저장매체에 저장되며 최종적으로 네트워크 상에 전달되는 데이터이다. 다음의 경우 이를 원본 데이터로 저장할 경우 저장 공간 상의 낭비 및 네트워크 트래픽이 커지기 때문에 이를 압축하거나 포맷화하여 저장하는 경우가 일반적인 방식이며 이를 직렬화(serialization)이라고 한다.</p></br><h2 id="비압축-SEC-형식"><a href="#비압축-SEC-형식" class="headerlink" title="비압축 SEC 형식"></a>비압축 SEC 형식</h2><p><img src="/img/contents/not-compressed-SEC.png"></p><p>타원곡선 암호방식에 있어서 공개키의 경우 타원곡선 상의 점으로 좌표형식($G_x, G_y$)이다. 이러한 특성에 기인해서 공개키를 직렬화하려고 한다. 다음의 적용할 방식은 공개키를 비압축식 SEC형식으로 직렬화하는 방식을 의미한다.</p><blockquote><ol><li>0x04의 1바이트를 접두부로 시작한다.</li><li>공개키의 $x$좌표를 32바이트 빅엔디언(Big-Endian)으로 표현한다.</li><li>공개키의 $y$좌표를 32바이트 빅엔디언(Big-Endian)으로 표현한다.</li></ol></blockquote></br><h2 id="압축-SEC-형식"><a href="#압축-SEC-형식" class="headerlink" title="압축 SEC 형식"></a>압축 SEC 형식</h2><p><img src="/img/contents/elliptic-curve-inf.png"></p><p>타원곡선 상의 점의 특성에 근거하여 공개키를 보다 효율적으로 표현할 수 있는 방식이 존재한다. 타원곡선의 경우 하나의 $x$좌표에 따라 총 2개의 $y$좌표가 존재하는 것을 확인할 수 있다. 결과적으로 다음의 점 $(x,y)\quad(x, -y)$ 이 해가 될 수 있다. </p><p>유한체에서 $-y $ % $ p &#x3D; (p-y) $ % $ p $ 이므로 $(x, p-y)$또한 만족시킬 수 있다.</p><p>유한체의 위수 $p$의 경우가 소수이므로 $y$가 짝수일 경우 $p-y$는 홀수, $y$가 홀수일 경우 $p-y$는 짝수가 된다. 결과적으로 $x$값과 $y$값의 홀수, 짝수 여부만 표시할 경우 공개키를 특정할 수 있다.</p></br><p><img src="/img/contents/compressed-SEC.png"></p></br><blockquote><ol><li>$G_y$ 값이 짝수면 0x02, 홀수면 0x03인 1바이트 접두부로 시작한다.</li><li>공개키의 $x$좌표를 32바이트 빅엔디언(Big-Endian) 정수로 표현한다.</li></ol></blockquote></br><h2 id="DER-서명-형식"><a href="#DER-서명-형식" class="headerlink" title="DER 서명 형식"></a>DER 서명 형식</h2><p><img src="/img/contents/DER.png"></p><p>서명을 직렬화 하기 위해서는 서명을 검증하기 위한 값이 $(r, s)$를 직렬화해야 한다. 또한 $s$값을 $r$값에서 유도할 수 없기 때문에 해당 정보를 압축할 순 없다. 초기 비트코인에서 이를 직렬화하기 위해서는 DER 형식을 사용하였다. </p><p>DER 서명 형식은 아래와 같은 과정으로 구성될 수 있다.</p></br><blockquote><ol><li>0x30의 1바이트를 접두부로 시작한다.</li><li>서명의 길이를 붙힌다. 보통은 0x44나 0x45가 된다.</li><li>$r$ 값의 시작을 표시하는 표식 바이트로 0x02를 붙힌다.</li><li>빅엔디언 정수로 $r$ 값을 표현한다. 첫 번째 바이트가 0x80보다 크거나 같으면 0x00을 앞에 붙힌다. 이후 처리된 $r$의 길이에 해당하는 바이트를 앞에 붙힌다.</li><li>$s$ 값의 시작을 표시하는 표식 바이트로 0x02를 붙힌다.</li><li>빅엔디언 정수로 $s$ 값을 표현한다. 첫 번째 바이트가 0x80보다 크거나 같으면 0x00을 앞에 붙힌다. 이후 처리된 $s$의 길이에 해당하는 바이트를 앞에 붙힌다.</li></ol></blockquote></br><div class="code-wrapper"><pre><code class="hljs">def der(r,s):    # 1. r 값의 처리    r_bin = r.to_bytes(32, byteorder=&#39;big&#39;)    if(r_bin[0] &amp; 0x80):        r_bin = b&#39;\x00&#39; + r_bin    r_bin_length = len(r_bin).to_bytes(1, byteorder=&#39;big&#39;)    #2. s 값의 처리    s_bin = s.to_bytes(32, byteorder=&#39;big&#39;)    if(s_bin[0] &amp; 0x80):        s_bin = b&#39;\x00&#39; + s_bin    s_bin_length = len(s_bin).to_bytes(1, byteorder=&#39;big&#39;)    #3. 서명 생성    signature = b&#39;\x02&#39; + r_bin_length + r_bin + b&#39;\x02&#39; + s_bin_length + s_bin    signature = b&#39;\x30&#39; + len(signature).to_bytes(1, byteorder=&#39;big&#39;) + signature    return signature</code></pre></div></br><h2 id="BASE58-인코딩"><a href="#BASE58-인코딩" class="headerlink" title="BASE58 인코딩"></a>BASE58 인코딩</h2><p>Base58 인코딩의 경우 바이너리 형태의 데이터를 사람이 읽어볼 수 있는 데이터로 표현하는 형태이다. 이를 수행하는 알고리즘의 경우 하단의 코드로 첨부하겠다.</p></br><div class="code-wrapper"><pre><code class="hljs">BASE58_ALPHABET = &#39;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&#39;def encode_base58(s):    count = 0    for c in s:        if c == 0:            count += 1        else:            break    num = int.from_bytes(s, &#39;big&#39;)    prefix = &#39;1&#39;*count    result = &#39;&#39;    print(&quot;[+] count: &quot; + str(count))    while num &gt; 0:        num, mod = divmod(num, 58)        result = BASE58_ALPHABET[mod] + result    return prefix + result</code></pre></div><p>다음의 해시 데이터는 다음과 같은 형태로 변환될 수 있다.</p><blockquote><p>7c076ff316692a3d7eb3c3bb0f8b1488cf72e1afcd929e29307032997a838a3d<br>eff69ef2b1bd93a66ed5219add4fb51e11a840f404876325a1e8ffe0529a2c<br>c84dcc25da0941ef00793d6bbaf99285453913e7ca307fe82dbaffa83c681494</p></blockquote><p>해당 데이터가 Base54 Encoding을 통해 산출되는 값이다.</p><blockquote><p>9MA8fRQrT4u8Zj8ZRd6MAiiyaxb2Y1CMpvVkHQu5hVM6<br>4fE3H2E6XMp4SsxtwinF7w9a34ooUrwWe4WsW1458Pd<br>EUuLxGCXgYPbyvZpG3zYcwMiDJzbbMvkYR47EX1wJXwR</p></blockquote></br><h2 id="비트코인의-주소-형식"><a href="#비트코인의-주소-형식" class="headerlink" title="비트코인의 주소 형식"></a>비트코인의 주소 형식</h2><p>압축 SEC형식의 경우도 33바이트[홀수&#x2F;짝수(1바이트) + $G_x$(32바이트)]이므로 데이터의 크기가 적은 크기가 아니다. 이를 20바이트 형태로 효율적으로 줄일 수 있는 방법이 존재한다.</p><blockquote><ol><li>메인넷 주소의 경우 0x00, 테스트넷 주소의 경우 0x6f로 접두부를 시작한다.</li><li>압축 혹은 비압축 SEC 형식의 주소를 sha256 해시함수에 입력한 후, 다시 ripemd160 해시함수에 입력한다.</li><li>1의 접두 바이트와 2의 해시결과를 합친다.</li><li>3에서 얻은 결과를 sha256을 통해 해쉬하며 해당 결과에서 첫 4바이트를 취한다.</li><li>3의 결과에서 4의 결과를 붙힌 후 이를 Base58로 부호화 한다.</li></ol></blockquote><p>이를 통해 총 20바이트 크기의 주소 형식을 산출할 수 있다.</p></br><h2 id="한줄평"><a href="#한줄평" class="headerlink" title="한줄평"></a>한줄평</h2><div class="code-wrapper"><pre><code class="hljs">파일 포맷 분석의 PTSD가 떠오릅니다.</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blockchain</tag>
      
      <tag>serialization</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[블록체인] 디지털 서명(부제: 자갈치로 뭘 할 수 있다고?)</title>
    <link href="/2021/03/11/post03/"/>
    <url>/2021/03/11/post03/</url>
    
    <content type="html"><![CDATA[<h2 id="블록체인-디지털-서명-부제-자갈치로-뭘-할-수-있다고"><a href="#블록체인-디지털-서명-부제-자갈치로-뭘-할-수-있다고" class="headerlink" title="[블록체인] 디지털 서명(부제: 자갈치로 뭘 할 수 있다고?)"></a>[블록체인] 디지털 서명(부제: 자갈치로 뭘 할 수 있다고?)</h2><p><img src="/img/contents/illon.jpg"></p></br><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>블록체인에서 어떤 누군가가 발행한 것이며 이를 어떻게 검증할 것인가에 관한 문제는 신뢰성이 보장되야하는 기록에서는 매우 중요한 요소 중 하나로 볼 수 있다. 정보 시스템 상에서 이러한 문제를 해결하기 위해서는 암호화가 도입되며 블록체인에서는 타원곡선암호화(ECC)가 활용된다. 이러한 수학적 원리의 기초 지식인 타원곡선에 대해서 다루었다. 해당 글은 타원곡선을 이용하여 도입하는 암호화인 타원곡선 암호(ECC)를 다룬다.</p></br><h2 id="유한체에서의-타원곡선"><a href="#유한체에서의-타원곡선" class="headerlink" title="유한체에서의 타원곡선"></a>유한체에서의 타원곡선</h2><p><img src="/img/contents/finitefieldeclip.JPG"></p><p>쉬운 이해를 위해서 타원곡선의 개형에 대해서 먼저 생각해보면 상단의 좌측과 같은 그림을 볼 수 있다. 만약 실수영역이 아닌 정의하였던 유한체(finite field)에서의 해당 그래프를 그리면 어떠한 결과를 볼 수 있는 지 예상해본 후 상단의 우측의 그림을 확인해본다. 직관적으로 보았을 때 규칙성이 없고 복잡한 형태의 모양을 확인할 수 있다. 해당 부분은 암호화의 핵심이 되므로 잘 기억해두자.</p></br><blockquote><p>유한체에서 정의된 타원곡선은 매우 불규칙한 형태를 띄고있다.</p></blockquote></br><h2 id="타원곡선-위-점의-스칼라-곱셈"><a href="#타원곡선-위-점의-스칼라-곱셈" class="headerlink" title="타원곡선 위 점의 스칼라 곱셈"></a>타원곡선 위 점의 스칼라 곱셈</h2><p>유한체에서 정의된 타원곡선의 경우도 점 덧셈이 수행될 수 있다. 또한 앞서 정의했던 덧셈연산의 성질을 띄고 있다는 점을 고려하여 다음의 예시에 대한 설명을 수행하겠다.</p></br>$(170,42) + (170,42) = 2·(170,142)$$2·(170,42) + (170,42) = 3·(170,142)$</br><p>점 덧셈에서의 결합법칙이 성립하는 성질로 인해서 덧셈은 곱셈연산으로 치환될 수 있다. 이를 의미하는 것이 스칼라 곱셈$^{scalar multiplication}$을 의미한다.</p><p>스칼라 곱셈의 경우 스칼라 곱셈을 수행하는 것은 어렵지 않지만 나눗셈의 경우는 어렵다. 이를 이산 로그 문제$^{discrete log problem}$이라고 한다. 또한 스칼라 곱셈을 수행하며 스칼라 값을 증가시키면 결과적으로 무한원점에 도달하게 된다.</p></br><p>첫번째, 스칼라 곰셈을 수행하는 것은 어렵지 않지만 나눗셈의 경우는 어렵다. 해당 특성에 대해서 보다 구체적으로 기재해두도록 하겠다. 예를 들어 $12·(47,71)$을 계산하는 것은 어렵지 않다. 하지만 $s·(47,71) &#x3D; (194,172)$를 수행하는 것은 상대적으로 어렵다. 해당 문제를 해결하기 위해서는 무차별 대입방법인 브루트포스를 통해서만 해결할 수 있으며 전형적인 NP(Non-deterministic Polynomial Problem)문제에 해당한다.</p><blockquote><p>스칼라 곱셈은 쉽지만 그에 대한 역연산은 어렵다.</p></blockquote></br><p>두번째, 특정 점에서 수행하는 스칼라 곱셈에서의 스칼라 값을 증가시키다보면 무한원점에 도달하게 된다. 해당 특성에 대해서 보다 구체적으로 설명하도록 하겠다. 특정 점을 G라고 하였을 경우를 고려해보자</p><p>$1·(G_x,G_y), 2·(G_x,G_y), 3·(G_x,G_y), 4·(G_x,G_y), … n·(G_x,G_y)$</p><p>다음과 같이 스칼라 값을 증가시키면 곱셈을 수행하다보면 무한원점에 도달하는 경우가 있다. n의 경우 유한한 특정 값이기 때문에 $유한군$^{finite group}$이라고 불리운다.</p><blockquote><p>유한군: ${G, 2G, 3G, 4G, … nG}, (nG &#x3D; 0)$</p></blockquote></br><h2 id="비트코인에서-사용하는-타원곡선"><a href="#비트코인에서-사용하는-타원곡선" class="headerlink" title="비트코인에서 사용하는 타원곡선"></a>비트코인에서 사용하는 타원곡선</h2><p>이전 섹션에서 언급하였던 유한체 타원곡선에서의 특성에 기인하여 공개키 암호화를 생성할 수 있다. 비트코인에서 사용하는 매개변수의 값을 언급한다.</p><blockquote><p>타원곡선 $y^2 &#x3D; x^3 + ax + b$<br>유한체에서의 위수인 소수p<br>생성점 G의 x와 y의 좌표값<br>G를 이용하여 생성한 군의 위수</p></blockquote><p>이에 대해서 각각 언급한다.</p><blockquote><p>a&#x3D;0, b&#x3D;7이며 타원곡선(secp256k1) $y^2 &#x3D; x^3 + 7$<br>$p &#x3D; 2^{256} - 2^{32} - 977$<br>$G_x &#x3D; 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798$<br>$G_y &#x3D; 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8$<br>$n &#x3D; 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141$</p></blockquote></br><p>모든 값의 경우는 256비트로 표현이 가능하다.</p></br><h2 id="공개키-암호"><a href="#공개키-암호" class="headerlink" title="공개키 암호"></a>공개키 암호</h2><p>서로 다른 두 점의 덧셈의 결과는 타원곡선과 접선의 방정식을 통해서 공식을 유도할 수 있다. </p></br><p>$P_1 &#x3D; (x_1, y_1),  P_2 &#x3D; (x_2, y_2),  P_3 &#x3D; (x_3, y_3)$</p><p>$P_1 + P_2 &#x3D; P_3$</p><p>$m &#x3D; (y_2 - y_1) &#x2F; (x_2 - x_1)$</p></br><p>다음과 더하고자 하는 두 개의 점의 값을 알 수 있고 이를 통해서 직선을 유도할 수 있다. </p></br><p>$y &#x3D; m(x - x_1) + y_1$</p></br><p>해당 직선을 타원곡선에 대입한다.</p></br><p>$y^2 &#x3D; x^3 + ax + b$</p></br><p>공식을 유도하는 방법에 대해서는 제시했고 세부적인 전개의 경우는 생략하도록 하겠다.</p><p>결과적으로 다음과 같이 점 덧셈 연산의 결과를 공식으로 표현할 수 있다.</p></br><p>$x_3 &#x3D; m^2 - x_1 - x_2$<br>$y_3 &#x3D; -(m(x_3 - x_1) + y_1) &#x3D; s(x_1 - x_3) - y_1$</p></br><h2 id="스칼라-곱셈을-이용한-서명-알고리즘"><a href="#스칼라-곱셈을-이용한-서명-알고리즘" class="headerlink" title="스칼라 곱셈을 이용한 서명 알고리즘"></a>스칼라 곱셈을 이용한 서명 알고리즘</h2><p>지금까지 수학적인 이해를 기반으로 작성을 수행하다보니 우리가 해당 개념을 통해서 어떤 것을 하려고 하였으며 어떤 것을 할 수 있는지 다시 돌이켜보려고 한다. 결과적으로 지금까지 다룬 개념을 통해서 하고 싶은 것은 권한이 있는 사용자만이 서명을 할 수 있으며 다른 사람들이 이것이 실제 사용자가 서명을 했는 지 검증을 하는 것을 수행할 수 있다.</p><p>비트코인에서 사용하는 알고리즘은 타원곡선 디지털 서명 알고리즘으로 ECDSA라고 불리운다. 이는 앞서 기재하였 던 특성을 이용하면 구현이 가능하다.</p></br><blockquote><p>$n_1·G &#x3D; result$</p></blockquote></br><p>다음과 같은 스칼라 곱 연산은 쉽지만 이에 대한 역연산은 어려움을 밝혔다. 이러한 특성에 기인하여 수식을 다시 작성해보겠다. </p></br><blockquote><p>$e·G &#x3D; P$ (P: 공개키, e: 비밀키)</p></blockquote></br><p>그리고 서명을 위한 또다른 수식을 하나 작성해보겠다.</p></br><blockquote><p>$k·G &#x3D; R$ (k: 임의의 값)</p></blockquote></br><p>상단의 기재된 수식들을 이용해서 새로운 수식을 전개하도록 하겠다.</p></br><blockquote><p>$uG + vP &#x3D; kG (u,v \neq 0)$<br>$vP &#x3D; (k-u)G$<br>$P &#x3D; ((k-u)&#x2F;v)G$</p></blockquote></br><p>비밀키 $e$를 알고 있어 $P$를 $eG$로 대체할 수 있을 경우,</p><blockquote><p>$e &#x3D; (k-u)&#x2F;v$</p></blockquote></br><p>다음의 공식에서 $u,v$를 알기 위해서는 이산 로그 문제의 해를 찾거나 비밀키 $e$를 알고 있어야 한다. 이산 로그 문제의 경우 해를 찾는 것이 상당히 어려우므로 비밀키 $e$를 알고 있어야 한다. 즉, 비밀키$e$를 알고 있는 경우가 $u,v$를 제공할 수 있다고 생각하면 된다.</p></br><h2 id="디지털-서명-알고리즘"><a href="#디지털-서명-알고리즘" class="headerlink" title="디지털 서명 알고리즘"></a>디지털 서명 알고리즘</h2><p>특정한 사람이 서명과 이에 대한 검증 목적을 위해서 서명해시$_{Signature Hash}$를 포함시킬 수 있다. 서명 해시는 서명자가 서명한 메시지의 요약본으로 생각하면 된다. 이를 $z$라고 기재하며 다음과 같이 $u,v$를 정의하도록 하겠다.</p><blockquote><p>$u &#x3D; z&#x2F;s, v &#x3D; r&#x2F;s$</p></blockquote><p>다음과 같이 확인할 수 있으며 r의 경우는 실제 서명이라고 생각하면 된다. 결과적으로 $s$를 구하기 위해서는 다음과 같이 수행할 수 있다.</p></br><blockquote><p>$uG + vP &#x3D; R &#x3D; kG$<br>$uG + veG &#x3D; kG$<br>$u + ve &#x3D; k$<br>$z&#x2F;s + re&#x2F;s &#x3D; k$<br>$(z + re)&#x2F;s &#x3D; k$</p></blockquote></br><p>결과적으로 다음과 같은 수식을 얻을 수 있다. 이를 서명 알고리즘이라고 한다.</p><blockquote><p>$s &#x3D; (z+re)&#x2F;k$</p></blockquote></br><h2 id="디지털-서명-검증"><a href="#디지털-서명-검증" class="headerlink" title="디지털 서명 검증"></a>디지털 서명 검증</h2><p>앞서 작성한 알고리즘을 이용해서 디지털 서명을 검증해보도록 한다. 디지털 서명이 완료된 시점에서 검증자는 검증에 필요한 정보를 전달받았다는 가정을 한다.</p></br><blockquote><ol><li>서명으로 (r,s)가 주어지고, 서명 메시지의 해시값으로 z가 주어진다. P는 서명자의 공개키를 의미한다.</li><li>$u &#x3D; z&#x2F;s, v &#x3D; r&#x2F;s$를 계산한다.</li><li>$uG + vP &#x3D; R$를 계산한다.</li><li>$R의 x$좌표와 전달된 $r$과 같다면 해당 서명은 유효하다..</li></ol></blockquote></br><p>실제 수식을 통한 유도과정은 직접 계산해보는 것을 추천한다.</p></br><h2 id="디지털-서명-생성"><a href="#디지털-서명-생성" class="headerlink" title="디지털 서명 생성"></a>디지털 서명 생성</h2><p>앞서 작성한 알고리즘을 이용해서 검증해야할 서명을 생성하는 과정을 기재하려고 한다.</p></br><blockquote><ol><li>서명메시지의 요약본인 서명해시 $z$가 주어지고 비밀키 $e$를 알고 있다.</li><li>서명을 위한 임의의 값 $k$를 선택한다.</li><li>$R &#x3D; kG$로 부터 R의 $x$ 좌표값인 $r$을 계산한다.</li><li>$s &#x3D; (z+re)&#x2F;k$를 통해 s를 계산한다.</li><li>서명 $(r,s)$를 검증자에게 전달한다.</li></ol></blockquote></br><div class="code-wrapper"><pre><code class="hljs">주의. 임의의 값 $k$를 선택할 경우는 매우 중요하다.</code></pre></div></br><h2 id="한줄평"><a href="#한줄평" class="headerlink" title="한줄평"></a>한줄평</h2><p><img src="/img/contents/jagalchi.jpg"></p><div class="code-wrapper"><pre><code class="hljs">도데체 이런건 어떻게 생각해내는 것 인가. 세상은 넓고 천재는 많다. </code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blockchain</tag>
      
      <tag>ecc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[블록체인] 타원곡선</title>
    <link href="/2021/03/10/post02/"/>
    <url>/2021/03/10/post02/</url>
    
    <content type="html"><![CDATA[<h2 id="블록체인-타원곡선"><a href="#블록체인-타원곡선" class="headerlink" title="[블록체인] 타원곡선"></a>[블록체인] 타원곡선</h2><p><img src="/img/contents/illon.jpg"></p></br><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>블록체인에서 어떤 누군가가 발행한 것이며 이를 어떻게 검증할 것인가에 관한 문제는 신뢰성이 보장되야하는 기록에서는 매우 중요한 요소 중 하나로 볼 수 있다. 정보 시스템 상에서 이러한 문제를 해결하기 위해서는 암호화가 도입되며 블록체인에서는 타원곡선암호화(ECC)가 활용된다. 이러한 수학적 원리를 이해하여 기초하기 위해서는 타원곡선에 대한 이해가 필요하다. 다음 글에서는 타원곡선에 대해서 다룬다.</p></br><h2 id="타원곡선"><a href="#타원곡선" class="headerlink" title="타원곡선"></a>타원곡선</h2><p><img src="/img/contents/tawon.png"></p></br><blockquote><p>$y^2 &#x3D; x^3 + ax + b$</p></blockquote></br><p>타원곡선은 상단의 기재된 식과 같은 형태를 의미한다. 기초적인 직교좌표계를 이해할 경우 다음과 같은 형태로 그려진다는 것은 직관적으로 파악할 수 있다. </p></br><blockquote><p>$y^2 &#x3D; x^3 + 7$</p></blockquote></br><p>계수 a&#x3D;0, b&#x3D;7일 경우를 특정할 수 있는데 이는 비트코인에서 사용되는 타원곡선 $secp256k1$ 을 의미한다.</p></br><h2 id="타원곡선상의-점-덧셈"><a href="#타원곡선상의-점-덧셈" class="headerlink" title="타원곡선상의 점 덧셈"></a>타원곡선상의 점 덧셈</h2><p><img src="/img/contents/9997934C5AD31B3B3F.jpg"></p><p>타원곡선 상의 점에서 덧셈을 정의할 수 있다. 타원곡선의 경우 일반적으로 하나의 직선과 세점에서 만나는 것을 고려할 수 있다. 이러한 특성을 이용하여 점의 덧셈을 정의할 수 있다.</p><blockquote><ol><li>두 점 P와 Q를 지나가는 직선이 타원곡선과 새롭게 만나는 점을 찾는다.</li><li>해당 점을 x축에 대해서 대칭을 시킨다.</li></ol></blockquote><p>다음과 같은 과정을 통해 얻어진 점이 점덧셈의 결과값으로 볼 수 있다. 의문이 들수도 있지만 일단 다음과 같은 형태로만 생각해보자.</p></br><h2 id="점-덧셈-성질"><a href="#점-덧셈-성질" class="headerlink" title="점 덧셈 성질"></a>점 덧셈 성질</h2><p>일반적인 덧셈 연산에서 적용되는 성질이 점 덧셈 연산에서도 지니고 있다.</p><blockquote><ol><li>항등원이 존재한다.</li><li>역원이 존재한다.</li><li>교환법칙이 성립한다.</li><li>결합법칙이 성립한다.</li></ol></blockquote><p>해당 성질 중 1, 2의 경우는 직관적으로 받아들이기 위해서는 어느정도의 약속처럼 이해를 해야한다. 그러므로 1,2의 경우에 대해서 먼저 기재하도록 하겠다.</p></br><p>항등원이란 연산을 취하였을 경우 원래의 값이 산출되는 경우를 의미하며, 역원이란 연산을 취하였을 경우 항등원이 산출되는 것을 의미한다.</p></br><blockquote><p>$A + I &#x3D; A$<br>$A + (-A) &#x3D; I$</p></blockquote></br><p><img src="/img/contents/elliptic-curve-inf.png"></p><p>다음의 그림을 통해 타원곡선에서의 점 덧셈의 항등원과 역원에 대한 이해를 보다 직관적으로 할 수 있다. 다음의 경우를 생각하면 Q를 -P라고 볼 수 있으며 두 점을 더한 값은 두 점을 지나는 직선을 고려해야한다. 해당 직선의 경우 y축과 평행하며 무한히 발산하는 곳에 위치한다고 생각할 수 있다. (사실 타원곡선과는 만나지는 않지만)</p><p>그러므로 해당 점을 무한원점$^{point at infinity}$라고 부른다.</p></br><blockquote><p>타원곡선 점 덧셈에서의 항등원 I는 무한원점$^{point at infinity}$이다.</p></blockquote></br></br><p>해당 성질 중 3, 4의 경우는 매우 직관적이다. 교환법칙의 경우는 그래프 상에서 서로 다른 두 점을 더하는 경우를 생각하는 경우를 고민하면 직관적으로 이해할 수 있다. 결합법칙의 경우는 $(A+B)+C &#x3D; A+(B+C)$가 성립한다고 볼 수 있다.</p></br><h2 id="점-덧셈-서로-다른-두-점의-덧셈"><a href="#점-덧셈-서로-다른-두-점의-덧셈" class="headerlink" title="점 덧셈 - 서로 다른 두 점의 덧셈"></a>점 덧셈 - 서로 다른 두 점의 덧셈</h2><p>서로 다른 두 점의 덧셈의 결과는 타원곡선과 접선의 방정식을 통해서 공식을 유도할 수 있다. </p></br><p>$P_1 &#x3D; (x_1, y_1),  P_2 &#x3D; (x_2, y_2),  P_3 &#x3D; (x_3, y_3)$</p><p>$P_1 + P_2 &#x3D; P_3$</p><p>$m &#x3D; (y_2 - y_1) &#x2F; (x_2 - x_1)$</p></br><p>다음과 더하고자 하는 두 개의 점의 값을 알 수 있고 이를 통해서 직선을 유도할 수 있다. </p></br><p>$y &#x3D; m(x - x_1) + y_1$</p></br><p>해당 직선을 타원곡선에 대입한다.</p></br><p>$y^2 &#x3D; x^3 + ax + b$</p></br><p>공식을 유도하는 방법에 대해서는 제시했고 세부적인 전개의 경우는 생략하도록 하겠다.</p><p>결과적으로 다음과 같이 점 덧셈 연산의 결과를 공식으로 표현할 수 있다.</p></br><p>$x_3 &#x3D; m^2 - x_1 - x_2$<br>$y_3 &#x3D; -(m(x_3 - x_1) + y_1) &#x3D; s(x_1 - x_3) - y_1$</p></br><h2 id="점-덧셈-두-점이-동일할-경우-P-1-x3D-P-2-y-neq0"><a href="#점-덧셈-두-점이-동일할-경우-P-1-x3D-P-2-y-neq0" class="headerlink" title="점 덧셈 - 두 점이 동일할 경우($P_1 &#x3D; P_2, y\neq0$)"></a>점 덧셈 - 두 점이 동일할 경우($P_1 &#x3D; P_2, y\neq0$)</h2><p><img src="/img/contents/99DDA9495AD3201428.png"></p><p>두 점이 동일할 경우는 다음과 같은 형태로 볼 수 있다. 타원곡선과 만나는 접선을 의미한다.</p><p>두 점이 동일하다는 것은 $x_1 &#x3D; x_2, y_1 &#x3D; y_2$라는 것을 고려할 수 있다.</p></br><p>$x_3 &#x3D; m^2 - x_1 - x_2$<br>$y_3 &#x3D; -(m(x_3 - x_1) + y_1) &#x3D; m(x_1 - x_3) - y_1$</p></br><p>앞서 구한 공식에서 두 점이 동일한 것을 고려해서 대입하면 </p></br><p>$x_3 &#x3D; m^2 - 2x_1$<br>$y_3 &#x3D; m(x_1 - x_3) - y_1$</p></br><p>다음과 같은 결과를 산출할 수 있다. 기울기 m의 경우는 미분을 통해서 얻을 수 있다.</p></br><h2 id="점-덧셈-두-점이-동일할-경우-P-1-x3D-P-2-y-x3D-0"><a href="#점-덧셈-두-점이-동일할-경우-P-1-x3D-P-2-y-x3D-0" class="headerlink" title="점 덧셈 - 두 점이 동일할 경우($P_1 &#x3D; P_2, y&#x3D;0$)"></a>점 덧셈 - 두 점이 동일할 경우($P_1 &#x3D; P_2, y&#x3D;0$)</h2><p>다음과 같은 경우를 생각할 수 있다. 타원곡선 자갈치 모양의 머리 부분(?)에서 점이 접할 경우는 $P_1 &#x3D; P_2$ 이면서 y 좌표가 0인 경우로 볼 수 있다. 해당 경우에는 기울이가 무한하다고 볼 수 있다. 일반적이지 않은 예외상황이므로 다음의 경우는 점 덧셈의 연산결과는 무한원점$^{point at infinity}$이라고 약속하겠다.</p></br><h2 id="한줄평"><a href="#한줄평" class="headerlink" title="한줄평"></a>한줄평</h2><div class="code-wrapper"><pre><code class="hljs">자갈치가 타원곡선 암호화의 기초가 된다니, 어떻게...</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blockchain</tag>
      
      <tag>elliptic-curve</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[블록체인] 유한체</title>
    <link href="/2021/03/09/post01/"/>
    <url>/2021/03/09/post01/</url>
    
    <content type="html"><![CDATA[<h2 id="블록체인-유한체"><a href="#블록체인-유한체" class="headerlink" title="[블록체인] 유한체"></a>[블록체인] 유한체</h2><p><img src="/img/contents/illon.jpg"></p></br><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>블록체인에서 어떤 누군가가 발행한 것이며 이를 어떻게 검증할 것인가에 관한 문제는 신뢰성이 보장되야하는 기록에서는 매우 중요한 요소 중 하나로 볼 수 있다. 정보 시스템 상에서 이러한 문제를 해결하기 위해서는 암호화가 도입되며 블록체인에서는 타원곡선암호화(ECC)가 활용된다. 이러한 수학적 원리를 이해하여 기초하기 위해서는 유한체에 대한 이해가 필요하다. 다음 글에서는 유한체에 대해서 다룬다.</p></br><h2 id="유한체-정의"><a href="#유한체-정의" class="headerlink" title="유한체 정의"></a>유한체 정의</h2><p>유한체를 직관적으로 이해하기 위해서는 기초 수학 중 하나인 덧셈과 곱셈의 성질을 생각해볼 필요가 있다. 유한체는 원소수를 유한하게 가지는 집합을 의마하며 모두 덧셈과 곱셈에 대해서 닫혀있다고 볼 수 있다. 이를 엄밀히 정리한다.</p><blockquote><ol><li>a와 b가 집합에 속해있을 경우, a+b와 a·b도 집합 안에 있다.</li><li>집합에 0으로 표기하는 원소가 존재하고 집합 내 다른 원소 a와 + 연산 결과는 a다. ( + 연산에 대한 항등원 존재)</li><li>집합에 1로 표기하는 원소가 존재하고 집합 내 다른 원소 a와 · 연산 결과는 a다. ( · 연산에 대한 항등원 존재)</li><li>집합의 원소 a와 + 연산 결과가 0이 되게하는 원소 b가 집합에 속해있다. ( + 연산에 대한 역원 존재)</li><li>0이 아닌 집합의 원소 a에 대해 a·b&#x3D;1이 되게하는 원소 b가 집합에 속해있다. ( · 연산에 대한 역원 존재)</li></ol></blockquote><p>앞서 기재된 정의에 만족하는 집합을 예시로 {0,1,2}, {-1,0,1}을 대입하여 생각해보면 보다 직관적으로 이해할 수 있다.</p></br><h2 id="유한집합"><a href="#유한집합" class="headerlink" title="유한집합"></a>유한집합</h2><p>유한체에서 다뤘던 집합을 고려해보면 집합의 개수가 유한하다. 그러므로 집합의 크기를 표현하는 값을 p라고 정할 수 있으며 해당 값을 집합의 위수(order)라고 부르도록 하겠다. 이러한 집합을 예시로 들면 $F_p &#x3D; {0, 1, 2, … p-1}$ 다음과 같은 예시를 들 수 있다. 그리고 앞으로는 소수(prime number)를 위수로 갖는 유한체만을 다루도록 한다.</p></br><h2 id="유한집합이-닫혀있으려면-덧셈-뺄셈-곱셈"><a href="#유한집합이-닫혀있으려면-덧셈-뺄셈-곱셈" class="headerlink" title="유한집합이 닫혀있으려면(덧셈, 뺄셈, 곱셈)"></a>유한집합이 닫혀있으려면(덧셈, 뺄셈, 곱셈)</h2><p>앞서 정의한 유한체의 경우는 $F_p &#x3D; {0, 1, 2, … p-1}$ 다음과 같다. 해당 경우를 고려하면 +연산과 ·연산에 닫혀있을 수 없다. 예시로 2 + $p-1$만 수행해도 $p+1$로 결과를 얻기에 유한체가 닫혀있다고 볼 수 없다. 그렇다면 이를 닫히게 하기 위해서는 어떤 마법을 부려야 하는가. 간단한 아이디어이지만 나는 생각하지 못했었다.</p><p>$F_{19} &#x3D; ${0, 1, 2, 3, 4, … 18} 위수 p가 19인 유한체를 고려해본다.</p></br>첫번째, $a +_{b} f = (a + b)$%19 와 같이 정의를 한다면 이는 모든 덧셈 연산에 대해서 닫혀있다.<p>두번째, $a -_{b} f &#x3D; (a - b)$%19 와 같이 정의를 한다면 이는 모든 뺄셈 연산에 대해서 닫혀있다.</p><p>(단, $-_{f}a &#x3D; $ -a % p,  예를 들어 -3%19일 경우 16으로 생각한다.)</p><blockquote><p>모든 덧셈 뺄셈 연산에 나머지 연산을 취한다.</p></blockquote></br><p>곱셈의 경우는 다음과 같은 예시로 설명하겠다.</p><p>$5·_{f}3$ &#x3D; 5 +$_{f}$5$ + _{f}$5 &#x3D; 15 % 19 &#x3D; 15</p><blockquote><p>일반적인 곱셈 후에 위수로 나머지 연산을 수행하면 된다. 거듭제곱도 마찬가지로 적용한다.</p></blockquote></br><h2 id="유한집합이-닫혀있으려면-나눗셈"><a href="#유한집합이-닫혀있으려면-나눗셈" class="headerlink" title="유한집합이 닫혀있으려면(나눗셈)"></a>유한집합이 닫혀있으려면(나눗셈)</h2><p>유한체에서의 나눗셈을 정의하기 위해서는 곱셈의 역원을 고려해야 한다. 먼저 앞서 밝힌 사실을 고려해보자.</p><p>$3 · _{f} 7 &#x3D; 21 $%19 &#x3D; 2로부터 $ 2&#x2F; _{f} 7 &#x3D; 3$이라는 등식이 성립한다.</p></br><p>이를 통해 나머지 연산의 경우를 구할 수 있다. 하지만 직접적으로 2&#x2F;$_{f}$7를 구하는 것은 어렵다.</p><blockquote><p>$n^{(p-1)}$%$p$ &#x3D; 1</p></blockquote></br><p>페르마의 소정리에 의하면 소수인 $p$와 0보다 큰 n에 대해 $n^{(p-1)}$ 은 항상 1이라는 것을 알 수 있다.<br>다음과 같은 성질에 유의하여 공식을 산출한다.</p><blockquote><p>$a &#x2F;_{f} b &#x3D; a· _{f} b ^{(p-2)}$</p></blockquote></br><p>다음의 공식을 적용하면 유한집합에서의 닫혀있는 나눗셈 연산을 수행할 수 있다.</p><h2 id="한줄평"><a href="#한줄평" class="headerlink" title="한줄평"></a>한줄평</h2><div class="code-wrapper"><pre><code class="hljs">선택과 집중, 암기는 암기, 이해는 이해, 레이텍은 어려워</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blockchain</tag>
      
      <tag>finite-field</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
