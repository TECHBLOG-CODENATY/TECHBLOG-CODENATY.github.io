<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>[블록체인] 유한체</title>
    <link href="/2021/03/09/page/"/>
    <url>/2021/03/09/page/</url>
    
    <content type="html"><![CDATA[<h2 id="블록체인-유한체"><a href="#블록체인-유한체" class="headerlink" title="[블록체인] 유한체"></a>[블록체인] 유한체</h2><p><img src="/img/contents/illon.jpg"></p><h2 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h2><p>샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다</p><h2 id="커널-kernel-이란"><a href="#커널-kernel-이란" class="headerlink" title="커널(kernel)이란"></a>커널(kernel)이란</h2><p><img src="/img/arch.png"></p><p>샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다샘플메시지입니다</p><h2 id="메모리-memory-란"><a href="#메모리-memory-란" class="headerlink" title="메모리(memory)란"></a>메모리(memory)란</h2><p><img src="/img/process_memory.png"></p><p>프로그램이 실행되기 위해서는 보조기억장치(HDD, SSD등)에서 주기억장치(RAM)에 로드 되어야 한다. 하나의 프로세스가 로드되면 32bit를 예시로 총 4GB의 가상메모리 공간에 위치하게 된다. 상단에 제시한 그림과 같은 형태를 나타낸다. 상위 주소(0xC0000000 ~ 0xFFFFFFFF)에는 커널의 위치한 주소가 되며 하위 주소(0x00000000~0xBFFFFFFFF)에는 흔히 알고 있는 유저 프로세스가 로드된다. 커널의 경우는 앞서 언급한 것과 같이 하드웨어의 직접적으로 접근할 수 있는 중요한 부분이며 이러한 이유로 스택 메모리를 확인하면 높은 주소에서 낮은 주소로 데이터가 쓰이는 것을 볼 수 있다.</p><h2 id="커널의-권한"><a href="#커널의-권한" class="headerlink" title="커널의 권한"></a>커널의 권한</h2><p><img src="/img/two_rise_sun.PNG" alt="하늘아래 태양은 두개가 될 수 없는 법."></p><p>커널은 프로세스들을 관리하기도 하고 주요한 정보들이 위치하기에 일반적으로 높은 권한을 지니고 있다. 그럼 다른 이야기를 해보자! 서로 친해지기 위해서 술게임을 하며 왕게임을 하는 데 가학적 성격장애가 있는 친구에게 권력이 부여된다면 타겟들은 인생이 힘들어진다. 또한 아무나 왕이 될 수 있다고하면 배가 산으로 가게되며 시스템 상에서는 아주 큰 문제가 발생할 수 있다. 그러므로 시스템에서는 특권을 지닌 커널 모드와 제한된 권한인 유저 모드로 나누어져 있다.</p><h2 id="커널에게-일을-시키고-싶어-시스템콜-syscall"><a href="#커널에게-일을-시키고-싶어-시스템콜-syscall" class="headerlink" title="커널에게 일을 시키고 싶어 - 시스템콜(syscall)"></a>커널에게 일을 시키고 싶어 - 시스템콜(syscall)</h2><p><img src="/img/systemcall.PNG"></p><p>그렇다면 어떻게 하면 커널을 공격할 수 있을 지 고민해보아야 한다. 일반적으로 유저 권한을 지닌 사용자 어플리케이션을 생각해보면 입력값(Input)이 될 수 있는 부분에서 문제가 발생한다. 커널도 마찬가지이다. 커널에서의 입력값(Input)이 될 수 있는 부분에서 문제가 발생한다. 이를 공격 표면(attack surface)라고 불린다. 가장 손쉽게 접근이 가능한 부분은 시스템 콜(syscall)이라고 볼 수 있다. 유저 모드에서는 직접적으로 컴퓨터의 중요 자원에 접근할 수 없기 때문에 커널 모드로의 전환이 일어나야 한다. 흔히 사용하는 printf와 같이 화면에 출력을 하는 함수의 경우도 저수준 함수로 변환되어 커널에게 시스템 콜이라는 인터럽트(interrupt)를 발생시키게 된다. </p><h2 id="커널의-공격-대상-attack-vector"><a href="#커널의-공격-대상-attack-vector" class="headerlink" title="커널의 공격 대상(attack vector)"></a>커널의 공격 대상(attack vector)</h2><p>커널의 주요한 자원에 접근하기 위해서는 직접적으로 접근할 수 없으며 시스템 콜과 같은 간접적인 형태로 접근할 수 있음을 언급하였다. 또한 정의된 시스템 콜 이외에도 리눅스의 경우 디바이스 드라이버 또는 파일 시스템이 모두 커널 모드에서 동작된다. 이러한 요소들까지 고려하면 리눅스의 attack surface의 경우는 시스템 콜 뿐만이 아닌 블루투스 디바이스 드라이버와 같은 많은 형태로 확장이 가능하다.</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blockchain</tag>
      
      <tag>finite-field</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
